[
  {
    "objectID": "LOGO_Hubi.html",
    "href": "LOGO_Hubi.html",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Clear the screen and initializing the field\n\nCLEARSCREEN &lt;- function () {\n  rm(list = ls(envir = LOGO), envir = LOGO)\n  new_field(5)\n}\n\n\nCS &lt;- function () {\n  CLEARSCREEN()\n}\n\n\nDon’t show the turtle cursor.\n\nHIDETURTLE &lt;- function () {\n  LOGO$turtle &lt;- FALSE\n  record_path(turtle = LOGO$turtle)\n}\n\n\nHT &lt;- function () {\n  HIDETURTLE()\n}\n\n\nShow the turtle cursor.\n\nSHOWTURTLE &lt;- function () {\n  LOGO$turtle &lt;- TRUE\n  record_path(turtle = LOGO$turtle)\n}\n\n\nST &lt;- function () {\n  SHOWTURTLE()\n}\n\n\nMove forward steps.\n\nFORWARD &lt;- function (step) {\n  angle &lt;- LOGO$path$rad[LOGO$pos] \n  x0 &lt;- LOGO$path$x[LOGO$pos]\n  y0 &lt;- LOGO$path$y[LOGO$pos]\n  \n  max_step &lt;- 1\n  \n  if (step &gt; max_step) {\n    n_step &lt;- abs(step)%/%(max_step * 1.5) + 1\n    Seq0 &lt;- seq(from = 0, to = 1, by = 1/n_step)\n    Seq0 &lt;- Seq0[-1]\n    steps &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n    steps &lt;- steps * step\n  } else {\n    steps &lt;- step\n  }\n  \n  x1 &lt;- x0 + cos(angle) * steps\n  y1 &lt;- y0 + sin(angle) * steps\n  \n  record_path(x = x1, y = y1, path_color = LOGO$path_color)\n}\n\n\nFD &lt;- function (step) {\n  FORWARD(step)\n}\n\n\nMove back steps.\n\nBACK &lt;- function (steps) {\n  FORWARD(-steps)\n}\n\n\nBK &lt;- function (steps) {\n  BACK(steps)\n}\n\n\nTurn left this many degrees. Negative degrees work too, they’ll turn it right.\n\nLEFT &lt;- function (degs) {\n  LOGO$heading &lt;- LOGO$heading + degs\n  LOGO$heading &lt;- LOGO$heading %% 360\n  record_path(rad = LOGO$heading * pi / 180)\n}\n\n\nLT &lt;- function (degs) {\n  LEFT(degs)\n}\n\n\nTurn right this many degrees.\n\nRIGHT &lt;- function (degs) {\n  LEFT(-degs)\n}\n\n\nRT &lt;- function (degs) {\n  RIGHT(degs)\n}\n\n\nTurn to an absolute heading of degrees.\n\nSETHEADING &lt;- function (deg) {\n  LOGO$heading &lt;- deg\n  record_path(rad = LOGO$heading * pi / 180)\n}\n\n\nSH &lt;- function (deg) {\n  SETHEADING(deg)\n}\n\n\nSet the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\nSETPOS &lt;- function (x1, y1) {\n  record_path(x = x1, y = y1, path_color = \"transparent\")\n}\n\n\nSP &lt;- function (x1, y1) {\n  SETPOS(x1, y1)\n}\n\n\nMove back to the home position.\n\nHOME &lt;- function () {\n  SETPOS(x1 = 0, y1 = 0)\n}\n\n\nSet the horizontal position to x.\n\nSETPOSX &lt;- function (x1) {\n  SETPOS(x1, y1 = LOGO$path$y[LOGO$pos])\n}\n\n\nSPX &lt;- function (x1) {\n  SETPOSX(x1)\n}\n\n\nSet the vertical position to y.\n\nSETPOSY &lt;- function (y1) {\n  SETPOS(x1 = LOGO$path$x[LOGO$pos], y1)\n}\n\n\nSPY &lt;- function (y1) {\n  SETPOSY(y1)\n}\n\n\n\n\nSETPATHCOLOR &lt;- function (path_color) {\n  LOGO$path_color &lt;- path_color\n  record_path(path_color = LOGO$path_color)\n}\n\n\nSPC &lt;- function (path_color) {\n  SETPATHCOLOR(path_color)\n}\n\n\n\nSETTURTLECOLOR &lt;- function (turtle_color) {\n  LOGO$turtle_color &lt;- turtle_color\n  record_path(turtle_color = LOGO$turtle_color)\n}\n\n\nSTC &lt;- function (turtle_color) {\n  SETTURTLECOLOR(turtle_color)\n}\n\n\n\nSETNEWCHUNK &lt;- function () {\n  LOGO$chunk &lt;- LOGO$chunk + 1\n  record_path(chunk = LOGO$chunk)\n}\n\n\nSNC &lt;- function () {\n  SETNEWCHUNK()\n}\n\n\n\nUNDOCHUNK &lt;- function () {\n  last_chunk &lt;- max(LOGO$path$chunk)\n  if (last_chunk &gt; 1) {\n    LOGO$path &lt;- LOGO$path[LOGO$path$chunk != last_chunk,]\n  } else {\n    CLEARSCREEN() \n  }\n  \n  LOGO$chunk &lt;- max(LOGO$path$chunk)\n  LOGO$pos &lt;- nrow(LOGO$path)\n  LOGO$heading &lt;- LOGO$path$rad[LOGO$pos] * 180 / pi \n  LOGO$turtle &lt;- LOGO$path$turtle[LOGO$pos]\n  LOGO$turtle_color &lt;- LOGO$path$turtle_color[LOGO$pos]\n  \n  last_pos &lt;- LOGO$pos\n  while (LOGO$path$path_color[last_pos] == \"transparent\" && last_pos &gt; 0) {\n    last_pos &lt;- last_pos - 1\n  }\n  if (last_pos == 0) {\n    LOGO$path_color &lt;- \"blue\"\n  } else {\n    LOGO$path_color &lt;- LOGO$path$path_color[last_pos]\n  }\n  REPLOT()\n}\n\n\nUNDO &lt;- function () {\n  UNDOCHUNK()\n}\n\n\n\nSETSPEED &lt;- function (speed) {\n  speed &lt;- pmax(speed, 1)\n  speed &lt;- round(speed)\n  LOGO$speed &lt;- speed\n}\n\n\nSPEED &lt;- function (speed) {\n  SETSPEED(speed)\n}\n\n\n\nREPLOT &lt;- function (chunk = FALSE) {\n  PLOT(chunk)\n}\n\n\n\nSAVESCREEN &lt;- function (name) {\n  name_gif &lt;- paste0(name, \".gif\")\n  REPLOT()\n  file.copy(from = file.path(tempdir(), \"Logo_Output.gif\"), \n            to = here( name_gif), \n            overwrite = TRUE)\n}\n\n\nSAVE &lt;- function (name) {\n  SAVESCREEN(name)\n}\n\n\n\nQUITLOGO &lt;- function () {\n  if (exists(\"LOGO\", envir = .GlobalEnv)) {\n  rm(LOGO, envir = .GlobalEnv)\n}\n}\n\n\nQUIT &lt;- function () {\n  QUITLOGO()\n}\n\n\n\n\nclean_prompt &lt;- function (Prompt) {\n  Prompt &lt;- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt &lt;- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt &lt;- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt &lt;- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt &lt;- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt &lt;- trimws(Prompt)\n  Prompt\n}\n\n\n\nbreakup_String &lt;- function(String) {\n  cl_String &lt;- clean_prompt(String)\n  split_String &lt;- strsplit(cl_String, \" \")[[1]]\n  df &lt;- data.frame(Code = split_String)\n  \n  n_func &lt;- 0\n  df$ID_Func &lt;- rep(0, nrow(df))\n  \n  n_par &lt;- 0\n  df$ID_Par &lt;- rep(0, nrow(df))\n  \n  ID &lt;- 1\n  df$ID_Repeat &lt;- rep(0, nrow(df))\n  \n  brakets &lt;- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat &lt;- rep(1, nrow(df))\n  \n  is_par_braket &lt;- FALSE\n  \n  i &lt;- 1\n  imax &lt;- nrow(df) + 1\n  \n  while ( i &lt; imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par &lt;- n_par + 1\n        is_par_braket &lt;- TRUE\n        i &lt;- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket &lt;- FALSE\n        i &lt;- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inLower &lt;- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] &lt;- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] &lt;- paste0(\"'\",inLower,\"'\")\n        } else if (exists(inLower)) {\n          df$Code[i] &lt;- inLower\n        }  else {\n          df$Code[i] &lt;- paste0(\"'\",df$Code[i],\"'\")\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] &lt;- FALSE\n      level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n      i &lt;- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par &lt;- n_par + 1\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inCaps &lt;- toupper(df$Code[i])\n        \n        is_LOGO_func &lt;- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func &lt;- n_func + 1\n          df$Code[i] &lt;- inCaps\n        }\n      \n        is_repeat &lt;- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func &lt;- n_func + 1\n          ID &lt;- ID + 1\n          i = i + 2\n          df$Code[i] &lt;- inCaps\n          brakets &lt;- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n\n\nCodeLine &lt;- \"CS repeat 2 [fd [-pi/n]] sPc [black]\"\ncl_splited &lt;-breakup_String(CodeLine)\ncl_splited\n\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n4   REPEAT       2      0         2        2\n5       FD       3      0         2        2\n7        -       3      1         2        2\n8       pi       3      1         2        2\n9        /       3      1         2        2\n10     (n)       3      1         2        2\n13     SPC       4      0         1        1\n15 'black'       4      2         1        1\n\n\n\n\ncreate_Calls &lt;- function (splited) {\n  Calls &lt;- splited %&gt;%\n    group_by(ID_Func, ID_Par) %&gt;%\n    mutate(Func_Par = ifelse(ID_Par &gt; 0,1,0),\n           Code = ifelse(first(ID_Par) &gt; 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %&gt;%\n    \n    group_by(ID_Func, Func_Par) %&gt;%\n    mutate(Code = ifelse(first(Func_Par) &gt; 0, \n                         paste0(Code, collapse = \", \"), \n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %&gt;%\n  \n    group_by(ID_Func) %&gt;%\n    mutate(Code = ifelse(n() &gt; 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(\")),\n           Code = paste0(Code, \")\")) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, .keep_all = TRUE) %&gt;%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %&gt;%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call &lt;- data.frame(Call = \"SETNEWCHUNK()\", ID = 1, n = 1)\n    last_call &lt;- data.frame(Call = \"PLOT()\", ID = 1, n = 1)\n    Calls &lt;- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n\n\nCallshort &lt;- create_Calls(cl_splited)\nCallshort \n\n           Call ID n\n1 SETNEWCHUNK()  1 1\n2          CS()  1 1\n3      REPEAT()  2 2\n4   FD(-pi/(n))  2 2\n5  SPC('black')  1 1\n6        PLOT()  1 1\n\n\n\n\nexpand_Repeats &lt;- function (Calls) {\n  IDmax &lt;- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax &gt; 1){\n    \n    dfm &lt;- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID &lt;- range(which(Calls$ID == IDmax))\n    n &lt;- Calls$n[rID[1]] \n    middle &lt;- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub &lt;- Calls[middle, ] %&gt;%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm &lt;- rbind(dfm,dfm_sub)\n      }\n    dfm$ID &lt;- Calls$ID[rID[1]-1]\n    dfm$n &lt;- Calls$n[rID[1]-1]\n    \n    before &lt;- 1:(rID[1] - 1)\n    dfb &lt;- Calls[before, ]\n    \n    after &lt;- (rID[2] + 1):nrow(Calls)\n    dfa &lt;- Calls[after, ]\n    \n    Calls &lt;- rbind(dfb,dfm,dfa)\n    IDmax &lt;- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n\n\nCalls &lt;- expand_Repeats(Callshort)\nCalls\n\n[1] \"SETNEWCHUNK()\" \"CS()\"          \"FD(-pi/1)\"     \"FD(-pi/2)\"    \n[5] \"SPC('black')\"  \"PLOT()\"       \n\n\n\n\nrun_prompt &lt;- function (Prompt) {\n  Prompt_splited &lt;- breakup_String(Prompt)\n  Callshort &lt;- create_Calls(Prompt_splited)\n  Calls &lt;- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    eval(parse(text = as.character(Calls[i])))\n    }\n}\n\n\n\nInitializing the game\n\nnew_field &lt;- function (size) {\n  dir_path &lt;- here(\"LOGO\", \"temp\")\n  chunk &lt;- 1\n  pos &lt;- 2\n  heading &lt;- 0\n  turtle &lt;- TRUE\n  turtle_color &lt;- \"red\"\n  path_color &lt;- \"blue\"\n  speed &lt;- 50\n  path &lt;- data.frame(\n    chunk = rep(1, pos),\n    x = rep(0, pos),\n    y = rep(0, pos),\n    rad = rep(0, pos),\n    path_color = rep(\"transparent\", pos),\n    turtle = c(FALSE, rep(turtle, pos - 1)),\n    turtle_color = rep(turtle_color, pos),\n    stringsAsFactors = FALSE\n  )\n  \n  LOGO$field_name = \"LOGO\"\n  LOGO$field_dir = here()\n  LOGO$size = abs(size)\n  LOGO$chunk = chunk\n  LOGO$pos = pos\n  LOGO$heading = heading\n  LOGO$turtle = turtle\n  LOGO$turtle_color = turtle_color\n  LOGO$path_color = path_color\n  LOGO$speed = speed\n  LOGO$path = path\n}\n\n\n\n record_path &lt;- function (chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   n &lt;- max(length(x),1)\n   template &lt;- LOGO$path[LOGO$pos, ]\n   \n   if (n &gt; 1) {\n     newrows &lt;- template[rep(1,n), ]\n     new_pos &lt;- LOGO$pos + (1:n)\n   } else {\n     newrows &lt;- template\n     new_pos &lt;- LOGO$pos + 1\n   }\n   \n   \n   if (!is.null(chunk)) newrows$chunk &lt;- chunk\n   if (!is.null(x)) newrows$x &lt;- x\n   if (!is.null(y)) newrows$y &lt;- y\n   if (!is.null(rad)) newrows$rad &lt;- rad\n   if (!is.null(path_color)) newrows$path_color &lt;- path_color\n   if (!is.null(turtle)) newrows$turtle &lt;- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color &lt;- turtle_color\n   \n   LOGO$path[new_pos,] &lt;- newrows\n   LOGO$pos &lt;- nrow(LOGO$path)\n}\n\n\n\n\nplot_field &lt;- function (stat) {\n  maxpath &lt;- ceiling(max(abs(LOGO$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  LOGO$size &lt;- max(c(LOGO$size, maxpath), na.rm = TRUE)\n\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-LOGO$size, LOGO$size),\n              ylim = c(-LOGO$size, LOGO$size),\n              asp = 1)\n  box()\n}\n\n\n\nplot_path &lt;- function (stat) {\n  if (stat &gt; 1) {\n    path_stat &lt;- LOGO$path[1:stat,]\n    segments(x0 = path_stat$x[-stat], \n             y0 = path_stat$y[-stat],\n             x1 = path_stat$x[-1], \n             y1 = path_stat$y[-1],\n             col = path_stat$path_color[-1], \n             lwd = 2)\n  }\n}\n\n\n\nplot_turtle &lt;- function (stat) {\n  show &lt;-  LOGO$path$turtle[stat]\n  if (show) {\n    pos_x &lt;- LOGO$path$x[stat]\n    pos_y &lt;- LOGO$path$y[stat]\n    symbols(x = pos_x,\n            y = pos_y,\n            circles = 0.02 * LOGO$size,\n            inches = FALSE,\n            fg = NA,\n            bg = LOGO$path$turtle_color[stat],\n            add = TRUE)\n    arrow_length &lt;- 0.1 * LOGO$size\n    angle &lt;- LOGO$path$rad[stat]\n    arrows(pos_x,\n           pos_y,\n           pos_x + cos(angle) * arrow_length,\n           pos_y + sin(angle) * arrow_length,\n           col = LOGO$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n}\n\n\n\nplot_stat &lt;- function (stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(LOGO$path)\n  \n  tmpfile &lt;- tempfile(fileext = \".png\")\n  png(filename = tmpfile, width = 600, height = 600, res = 150)\n  \n  plot_field(stat)\n  plot_path(stat)\n  plot_turtle(stat)\n  \n  dev.off()\n  img &lt;- image_read(tmpfile)\n  \n  unlink(tmpfile)\n\n  img\n\n}\n\n\n\nPLOT &lt;- function (chunk = TRUE) {\n  invisible(NULL)\n  \n  if (chunk) {\n    Range &lt;- range(which(LOGO$path$chunk == max(LOGO$chunk)))\n    rmin &lt;- max(2,Range[1])\n    rmax &lt;- Range[2]\n    } else {\n      rmin &lt;- 2\n      rmax &lt;- nrow(LOGO$path)\n    }\n  \n  step &lt;- LOGO$speed/(rmax-rmin)\n  step &lt;- pmin(pmax(step, 1/200), 1)\n  Seq0 &lt;- seq(from = 0, to = 1, by = step)\n  plot_seq &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq &lt;- (rmax - rmin) * plot_seq + rmin\n  plot_seq &lt;- round(plot_seq)\n  plot_seq &lt;- unique(plot_seq)\n  \n  img_list &lt;- lapply(plot_seq, function(i) plot_stat(i))\n  Logo_Output &lt;- image_animate(image_join(img_list), \n                             fps = 10, loop = 1,\n                             optimize = TRUE) \n  \n  gif_path &lt;- file.path(tempdir(), \"Logo_Output.gif\")\n  image_write(Logo_Output, path = gif_path)\n  \n  print(Logo_Output)\n}\n\n\n\nrun_LOGO &lt;- function(string) {\n  if (!exists(\"LOGO\", envir = .GlobalEnv)) {\n    assign(\"LOGO\", new.env(), envir = .GlobalEnv)\n    LOGO &lt;- get(\"LOGO\", envir = .GlobalEnv)\n    new_field(5)\n  } else {\n    LOGO &lt;- get(\"LOGO\", envir = .GlobalEnv)\n  }\n  run_prompt(string)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#basic-commands",
    "href": "LOGO_Hubi.html#basic-commands",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Clear the screen and initializing the field\n\nCLEARSCREEN &lt;- function () {\n  rm(list = ls(envir = LOGO), envir = LOGO)\n  new_field(5)\n}\n\n\nCS &lt;- function () {\n  CLEARSCREEN()\n}\n\n\nDon’t show the turtle cursor.\n\nHIDETURTLE &lt;- function () {\n  LOGO$turtle &lt;- FALSE\n  record_path(turtle = LOGO$turtle)\n}\n\n\nHT &lt;- function () {\n  HIDETURTLE()\n}\n\n\nShow the turtle cursor.\n\nSHOWTURTLE &lt;- function () {\n  LOGO$turtle &lt;- TRUE\n  record_path(turtle = LOGO$turtle)\n}\n\n\nST &lt;- function () {\n  SHOWTURTLE()\n}\n\n\nMove forward steps.\n\nFORWARD &lt;- function (step) {\n  angle &lt;- LOGO$path$rad[LOGO$pos] \n  x0 &lt;- LOGO$path$x[LOGO$pos]\n  y0 &lt;- LOGO$path$y[LOGO$pos]\n  \n  max_step &lt;- 1\n  \n  if (step &gt; max_step) {\n    n_step &lt;- abs(step)%/%(max_step * 1.5) + 1\n    Seq0 &lt;- seq(from = 0, to = 1, by = 1/n_step)\n    Seq0 &lt;- Seq0[-1]\n    steps &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n    steps &lt;- steps * step\n  } else {\n    steps &lt;- step\n  }\n  \n  x1 &lt;- x0 + cos(angle) * steps\n  y1 &lt;- y0 + sin(angle) * steps\n  \n  record_path(x = x1, y = y1, path_color = LOGO$path_color)\n}\n\n\nFD &lt;- function (step) {\n  FORWARD(step)\n}\n\n\nMove back steps.\n\nBACK &lt;- function (steps) {\n  FORWARD(-steps)\n}\n\n\nBK &lt;- function (steps) {\n  BACK(steps)\n}\n\n\nTurn left this many degrees. Negative degrees work too, they’ll turn it right.\n\nLEFT &lt;- function (degs) {\n  LOGO$heading &lt;- LOGO$heading + degs\n  LOGO$heading &lt;- LOGO$heading %% 360\n  record_path(rad = LOGO$heading * pi / 180)\n}\n\n\nLT &lt;- function (degs) {\n  LEFT(degs)\n}\n\n\nTurn right this many degrees.\n\nRIGHT &lt;- function (degs) {\n  LEFT(-degs)\n}\n\n\nRT &lt;- function (degs) {\n  RIGHT(degs)\n}\n\n\nTurn to an absolute heading of degrees.\n\nSETHEADING &lt;- function (deg) {\n  LOGO$heading &lt;- deg\n  record_path(rad = LOGO$heading * pi / 180)\n}\n\n\nSH &lt;- function (deg) {\n  SETHEADING(deg)\n}\n\n\nSet the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\nSETPOS &lt;- function (x1, y1) {\n  record_path(x = x1, y = y1, path_color = \"transparent\")\n}\n\n\nSP &lt;- function (x1, y1) {\n  SETPOS(x1, y1)\n}\n\n\nMove back to the home position.\n\nHOME &lt;- function () {\n  SETPOS(x1 = 0, y1 = 0)\n}\n\n\nSet the horizontal position to x.\n\nSETPOSX &lt;- function (x1) {\n  SETPOS(x1, y1 = LOGO$path$y[LOGO$pos])\n}\n\n\nSPX &lt;- function (x1) {\n  SETPOSX(x1)\n}\n\n\nSet the vertical position to y.\n\nSETPOSY &lt;- function (y1) {\n  SETPOS(x1 = LOGO$path$x[LOGO$pos], y1)\n}\n\n\nSPY &lt;- function (y1) {\n  SETPOSY(y1)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#gimmicks",
    "href": "LOGO_Hubi.html#gimmicks",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "SETPATHCOLOR &lt;- function (path_color) {\n  LOGO$path_color &lt;- path_color\n  record_path(path_color = LOGO$path_color)\n}\n\n\nSPC &lt;- function (path_color) {\n  SETPATHCOLOR(path_color)\n}\n\n\n\nSETTURTLECOLOR &lt;- function (turtle_color) {\n  LOGO$turtle_color &lt;- turtle_color\n  record_path(turtle_color = LOGO$turtle_color)\n}\n\n\nSTC &lt;- function (turtle_color) {\n  SETTURTLECOLOR(turtle_color)\n}\n\n\n\nSETNEWCHUNK &lt;- function () {\n  LOGO$chunk &lt;- LOGO$chunk + 1\n  record_path(chunk = LOGO$chunk)\n}\n\n\nSNC &lt;- function () {\n  SETNEWCHUNK()\n}\n\n\n\nUNDOCHUNK &lt;- function () {\n  last_chunk &lt;- max(LOGO$path$chunk)\n  if (last_chunk &gt; 1) {\n    LOGO$path &lt;- LOGO$path[LOGO$path$chunk != last_chunk,]\n  } else {\n    CLEARSCREEN() \n  }\n  \n  LOGO$chunk &lt;- max(LOGO$path$chunk)\n  LOGO$pos &lt;- nrow(LOGO$path)\n  LOGO$heading &lt;- LOGO$path$rad[LOGO$pos] * 180 / pi \n  LOGO$turtle &lt;- LOGO$path$turtle[LOGO$pos]\n  LOGO$turtle_color &lt;- LOGO$path$turtle_color[LOGO$pos]\n  \n  last_pos &lt;- LOGO$pos\n  while (LOGO$path$path_color[last_pos] == \"transparent\" && last_pos &gt; 0) {\n    last_pos &lt;- last_pos - 1\n  }\n  if (last_pos == 0) {\n    LOGO$path_color &lt;- \"blue\"\n  } else {\n    LOGO$path_color &lt;- LOGO$path$path_color[last_pos]\n  }\n  REPLOT()\n}\n\n\nUNDO &lt;- function () {\n  UNDOCHUNK()\n}\n\n\n\nSETSPEED &lt;- function (speed) {\n  speed &lt;- pmax(speed, 1)\n  speed &lt;- round(speed)\n  LOGO$speed &lt;- speed\n}\n\n\nSPEED &lt;- function (speed) {\n  SETSPEED(speed)\n}\n\n\n\nREPLOT &lt;- function (chunk = FALSE) {\n  PLOT(chunk)\n}\n\n\n\nSAVESCREEN &lt;- function (name) {\n  name_gif &lt;- paste0(name, \".gif\")\n  REPLOT()\n  file.copy(from = file.path(tempdir(), \"Logo_Output.gif\"), \n            to = here( name_gif), \n            overwrite = TRUE)\n}\n\n\nSAVE &lt;- function (name) {\n  SAVESCREEN(name)\n}\n\n\n\nQUITLOGO &lt;- function () {\n  if (exists(\"LOGO\", envir = .GlobalEnv)) {\n  rm(LOGO, envir = .GlobalEnv)\n}\n}\n\n\nQUIT &lt;- function () {\n  QUITLOGO()\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#parsing-prompts",
    "href": "LOGO_Hubi.html#parsing-prompts",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "clean_prompt &lt;- function (Prompt) {\n  Prompt &lt;- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt &lt;- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt &lt;- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt &lt;- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt &lt;- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt &lt;- trimws(Prompt)\n  Prompt\n}\n\n\n\nbreakup_String &lt;- function(String) {\n  cl_String &lt;- clean_prompt(String)\n  split_String &lt;- strsplit(cl_String, \" \")[[1]]\n  df &lt;- data.frame(Code = split_String)\n  \n  n_func &lt;- 0\n  df$ID_Func &lt;- rep(0, nrow(df))\n  \n  n_par &lt;- 0\n  df$ID_Par &lt;- rep(0, nrow(df))\n  \n  ID &lt;- 1\n  df$ID_Repeat &lt;- rep(0, nrow(df))\n  \n  brakets &lt;- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat &lt;- rep(1, nrow(df))\n  \n  is_par_braket &lt;- FALSE\n  \n  i &lt;- 1\n  imax &lt;- nrow(df) + 1\n  \n  while ( i &lt; imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par &lt;- n_par + 1\n        is_par_braket &lt;- TRUE\n        i &lt;- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket &lt;- FALSE\n        i &lt;- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inLower &lt;- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] &lt;- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] &lt;- paste0(\"'\",inLower,\"'\")\n        } else if (exists(inLower)) {\n          df$Code[i] &lt;- inLower\n        }  else {\n          df$Code[i] &lt;- paste0(\"'\",df$Code[i],\"'\")\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] &lt;- FALSE\n      level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n      i &lt;- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par &lt;- n_par + 1\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inCaps &lt;- toupper(df$Code[i])\n        \n        is_LOGO_func &lt;- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func &lt;- n_func + 1\n          df$Code[i] &lt;- inCaps\n        }\n      \n        is_repeat &lt;- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func &lt;- n_func + 1\n          ID &lt;- ID + 1\n          i = i + 2\n          df$Code[i] &lt;- inCaps\n          brakets &lt;- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n\n\nCodeLine &lt;- \"CS repeat 2 [fd [-pi/n]] sPc [black]\"\ncl_splited &lt;-breakup_String(CodeLine)\ncl_splited\n\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n4   REPEAT       2      0         2        2\n5       FD       3      0         2        2\n7        -       3      1         2        2\n8       pi       3      1         2        2\n9        /       3      1         2        2\n10     (n)       3      1         2        2\n13     SPC       4      0         1        1\n15 'black'       4      2         1        1\n\n\n\n\ncreate_Calls &lt;- function (splited) {\n  Calls &lt;- splited %&gt;%\n    group_by(ID_Func, ID_Par) %&gt;%\n    mutate(Func_Par = ifelse(ID_Par &gt; 0,1,0),\n           Code = ifelse(first(ID_Par) &gt; 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %&gt;%\n    \n    group_by(ID_Func, Func_Par) %&gt;%\n    mutate(Code = ifelse(first(Func_Par) &gt; 0, \n                         paste0(Code, collapse = \", \"), \n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %&gt;%\n  \n    group_by(ID_Func) %&gt;%\n    mutate(Code = ifelse(n() &gt; 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(\")),\n           Code = paste0(Code, \")\")) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, .keep_all = TRUE) %&gt;%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %&gt;%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call &lt;- data.frame(Call = \"SETNEWCHUNK()\", ID = 1, n = 1)\n    last_call &lt;- data.frame(Call = \"PLOT()\", ID = 1, n = 1)\n    Calls &lt;- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n\n\nCallshort &lt;- create_Calls(cl_splited)\nCallshort \n\n           Call ID n\n1 SETNEWCHUNK()  1 1\n2          CS()  1 1\n3      REPEAT()  2 2\n4   FD(-pi/(n))  2 2\n5  SPC('black')  1 1\n6        PLOT()  1 1\n\n\n\n\nexpand_Repeats &lt;- function (Calls) {\n  IDmax &lt;- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax &gt; 1){\n    \n    dfm &lt;- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID &lt;- range(which(Calls$ID == IDmax))\n    n &lt;- Calls$n[rID[1]] \n    middle &lt;- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub &lt;- Calls[middle, ] %&gt;%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm &lt;- rbind(dfm,dfm_sub)\n      }\n    dfm$ID &lt;- Calls$ID[rID[1]-1]\n    dfm$n &lt;- Calls$n[rID[1]-1]\n    \n    before &lt;- 1:(rID[1] - 1)\n    dfb &lt;- Calls[before, ]\n    \n    after &lt;- (rID[2] + 1):nrow(Calls)\n    dfa &lt;- Calls[after, ]\n    \n    Calls &lt;- rbind(dfb,dfm,dfa)\n    IDmax &lt;- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n\n\nCalls &lt;- expand_Repeats(Callshort)\nCalls\n\n[1] \"SETNEWCHUNK()\" \"CS()\"          \"FD(-pi/1)\"     \"FD(-pi/2)\"    \n[5] \"SPC('black')\"  \"PLOT()\"       \n\n\n\n\nrun_prompt &lt;- function (Prompt) {\n  Prompt_splited &lt;- breakup_String(Prompt)\n  Callshort &lt;- create_Calls(Prompt_splited)\n  Calls &lt;- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    eval(parse(text = as.character(Calls[i])))\n    }\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#helper-functions",
    "href": "LOGO_Hubi.html#helper-functions",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Initializing the game\n\nnew_field &lt;- function (size) {\n  dir_path &lt;- here(\"LOGO\", \"temp\")\n  chunk &lt;- 1\n  pos &lt;- 2\n  heading &lt;- 0\n  turtle &lt;- TRUE\n  turtle_color &lt;- \"red\"\n  path_color &lt;- \"blue\"\n  speed &lt;- 50\n  path &lt;- data.frame(\n    chunk = rep(1, pos),\n    x = rep(0, pos),\n    y = rep(0, pos),\n    rad = rep(0, pos),\n    path_color = rep(\"transparent\", pos),\n    turtle = c(FALSE, rep(turtle, pos - 1)),\n    turtle_color = rep(turtle_color, pos),\n    stringsAsFactors = FALSE\n  )\n  \n  LOGO$field_name = \"LOGO\"\n  LOGO$field_dir = here()\n  LOGO$size = abs(size)\n  LOGO$chunk = chunk\n  LOGO$pos = pos\n  LOGO$heading = heading\n  LOGO$turtle = turtle\n  LOGO$turtle_color = turtle_color\n  LOGO$path_color = path_color\n  LOGO$speed = speed\n  LOGO$path = path\n}\n\n\n\n record_path &lt;- function (chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   n &lt;- max(length(x),1)\n   template &lt;- LOGO$path[LOGO$pos, ]\n   \n   if (n &gt; 1) {\n     newrows &lt;- template[rep(1,n), ]\n     new_pos &lt;- LOGO$pos + (1:n)\n   } else {\n     newrows &lt;- template\n     new_pos &lt;- LOGO$pos + 1\n   }\n   \n   \n   if (!is.null(chunk)) newrows$chunk &lt;- chunk\n   if (!is.null(x)) newrows$x &lt;- x\n   if (!is.null(y)) newrows$y &lt;- y\n   if (!is.null(rad)) newrows$rad &lt;- rad\n   if (!is.null(path_color)) newrows$path_color &lt;- path_color\n   if (!is.null(turtle)) newrows$turtle &lt;- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color &lt;- turtle_color\n   \n   LOGO$path[new_pos,] &lt;- newrows\n   LOGO$pos &lt;- nrow(LOGO$path)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#plot-functions",
    "href": "LOGO_Hubi.html#plot-functions",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "plot_field &lt;- function (stat) {\n  maxpath &lt;- ceiling(max(abs(LOGO$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  LOGO$size &lt;- max(c(LOGO$size, maxpath), na.rm = TRUE)\n\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-LOGO$size, LOGO$size),\n              ylim = c(-LOGO$size, LOGO$size),\n              asp = 1)\n  box()\n}\n\n\n\nplot_path &lt;- function (stat) {\n  if (stat &gt; 1) {\n    path_stat &lt;- LOGO$path[1:stat,]\n    segments(x0 = path_stat$x[-stat], \n             y0 = path_stat$y[-stat],\n             x1 = path_stat$x[-1], \n             y1 = path_stat$y[-1],\n             col = path_stat$path_color[-1], \n             lwd = 2)\n  }\n}\n\n\n\nplot_turtle &lt;- function (stat) {\n  show &lt;-  LOGO$path$turtle[stat]\n  if (show) {\n    pos_x &lt;- LOGO$path$x[stat]\n    pos_y &lt;- LOGO$path$y[stat]\n    symbols(x = pos_x,\n            y = pos_y,\n            circles = 0.02 * LOGO$size,\n            inches = FALSE,\n            fg = NA,\n            bg = LOGO$path$turtle_color[stat],\n            add = TRUE)\n    arrow_length &lt;- 0.1 * LOGO$size\n    angle &lt;- LOGO$path$rad[stat]\n    arrows(pos_x,\n           pos_y,\n           pos_x + cos(angle) * arrow_length,\n           pos_y + sin(angle) * arrow_length,\n           col = LOGO$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n}\n\n\n\nplot_stat &lt;- function (stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(LOGO$path)\n  \n  tmpfile &lt;- tempfile(fileext = \".png\")\n  png(filename = tmpfile, width = 600, height = 600, res = 150)\n  \n  plot_field(stat)\n  plot_path(stat)\n  plot_turtle(stat)\n  \n  dev.off()\n  img &lt;- image_read(tmpfile)\n  \n  unlink(tmpfile)\n\n  img\n\n}\n\n\n\nPLOT &lt;- function (chunk = TRUE) {\n  invisible(NULL)\n  \n  if (chunk) {\n    Range &lt;- range(which(LOGO$path$chunk == max(LOGO$chunk)))\n    rmin &lt;- max(2,Range[1])\n    rmax &lt;- Range[2]\n    } else {\n      rmin &lt;- 2\n      rmax &lt;- nrow(LOGO$path)\n    }\n  \n  step &lt;- LOGO$speed/(rmax-rmin)\n  step &lt;- pmin(pmax(step, 1/200), 1)\n  Seq0 &lt;- seq(from = 0, to = 1, by = step)\n  plot_seq &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq &lt;- (rmax - rmin) * plot_seq + rmin\n  plot_seq &lt;- round(plot_seq)\n  plot_seq &lt;- unique(plot_seq)\n  \n  img_list &lt;- lapply(plot_seq, function(i) plot_stat(i))\n  Logo_Output &lt;- image_animate(image_join(img_list), \n                             fps = 10, loop = 1,\n                             optimize = TRUE) \n  \n  gif_path &lt;- file.path(tempdir(), \"Logo_Output.gif\")\n  image_write(Logo_Output, path = gif_path)\n  \n  print(Logo_Output)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#application",
    "href": "LOGO_Hubi.html#application",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "run_LOGO &lt;- function(string) {\n  if (!exists(\"LOGO\", envir = .GlobalEnv)) {\n    assign(\"LOGO\", new.env(), envir = .GlobalEnv)\n    LOGO &lt;- get(\"LOGO\", envir = .GlobalEnv)\n    new_field(5)\n  } else {\n    LOGO &lt;- get(\"LOGO\", envir = .GlobalEnv)\n  }\n  run_prompt(string)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#example-from-the-homepage",
    "href": "LOGO_Hubi.html#example-from-the-homepage",
    "title": "Logo with Gimmicks",
    "section": "Example from the homepage",
    "text": "Example from the homepage\nwith some fancy shadow and color effects\n\nrun_LOGO(\"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\")\nrun_LOGO(\"REPEAT 20 [RepeaT 180 [FD 1 RT 2] RT 18]\")\nrun_LOGO(\"SPEED 100\")\nrun_LOGO(\"Home SpC [gREEN] StC [blue]\")\nrun_LOGO(\"REPEaT 20.1 [rEPEAT 180 [fD 1 RT 2] RT 18]\")\nrun_LOGO(\"UndoChunk\")\nrun_LOGO(\"SpC [blue] StC [green]\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [green] StC [red] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [yellow] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [red] rt 18 ht\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 360 [fD 0.5 RT 1] RT 72]\")\n\nSaved Output\nyou can also save the output (Plot) for showing it around later\n\nrun_LOGO(\"SPEED 1 saVe [Logo01]\")"
  },
  {
    "objectID": "LOGO_Hubi.html#other-exercises",
    "href": "LOGO_Hubi.html#other-exercises",
    "title": "Logo with Gimmicks",
    "section": "Other Exercises",
    "text": "Other Exercises\nSince n is also used as a loop variable in my program, handling many other exercises doesn’t pose any issues.\nhttps://softwareprogramming4kids.com/loops-in-logo/\nExercise 1:\n\nrun_LOGO(\"CS\")\nrun_LOGO(\"REPEAT 80 [FD [N*2] RT 90]\")\nrun_LOGO(\"undo\")\nrun_LOGO(\"REPEAT 80 [FD [N*2^(N/40)] RT 90]\")\n\n\nrun_LOGO(\"SPEED 1 saVe [Logo02]\")\n\n\nExercise 2:\n\nrun_LOGO(\"CS REPEAT 50 [ FD [n * 5]  RIGHT 144 ]\")\n\n\nrun_LOGO(\"SPEED 1 saVe [Logo03]\")\n\n\nExercise 3:\n\nrun_LOGO(\"CS REPEAT 150 [ FD [n * 2]  RT 91 ]\")\n\n\nrun_LOGO(\"SPEED 1 saVe [Logo04]\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Goal",
    "section": "",
    "text": "Logo goes back much earlier than the Apple II, it was developed in 1967 by Cynthia Solomon, Wally Feurzig, and Seymour Papert. That’s five years before C and 24 years before Python! The three worked at Bolt, Beranek, and Newman (BBN), famous for all kinds of other computing history. BBN built the first Interface Message Processors (early routers) in 1968 for the ARPANET, which would evolve into the modern internet. …learn more\n\n\nOverview of some turtle commands and their shorthand equivalents:\nCLEARSCREEN - Clear the screen. (Shorthand: CS)\nHIDETURTLE - Don’t show the turtle cursor. (HT)\nSHOWTURTLE - Show the turtle cursor. (ST)\nHOME - Move back to the home position.\nFORWARD steps - Move forward steps. (FD)\nBACK steps - Move back steps. (BK)\nLEFT degrees - Turn left this many degrees. Negative degrees work too, they’ll turn it right. (LT)\nRIGHT degrees - Turn right this many degrees. (RT)\nSETHEADING degrees - Turn to an absolute heading of degrees. (SETH)\nSETPOS [x y] - Set the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\nSETX x - Set the horizontal position to x.\nSETY y - Set the vertical position to y.\n\n\n\nGenerate this code-Line with your own Logo-Code:\nREPEAT 20 [REPEAT 180 [FD 1 RT 2] RT 18]"
  },
  {
    "objectID": "index.html#commands",
    "href": "index.html#commands",
    "title": "Goal",
    "section": "",
    "text": "Overview of some turtle commands and their shorthand equivalents:\nCLEARSCREEN - Clear the screen. (Shorthand: CS)\nHIDETURTLE - Don’t show the turtle cursor. (HT)\nSHOWTURTLE - Show the turtle cursor. (ST)\nHOME - Move back to the home position.\nFORWARD steps - Move forward steps. (FD)\nBACK steps - Move back steps. (BK)\nLEFT degrees - Turn left this many degrees. Negative degrees work too, they’ll turn it right. (LT)\nRIGHT degrees - Turn right this many degrees. (RT)\nSETHEADING degrees - Turn to an absolute heading of degrees. (SETH)\nSETPOS [x y] - Set the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\nSETX x - Set the horizontal position to x.\nSETY y - Set the vertical position to y."
  },
  {
    "objectID": "index.html#planed-result",
    "href": "index.html#planed-result",
    "title": "Goal",
    "section": "",
    "text": "Generate this code-Line with your own Logo-Code:\nREPEAT 20 [REPEAT 180 [FD 1 RT 2] RT 18]"
  }
]