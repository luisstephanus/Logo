{
  "hash": "5f3d425b53d11251d9f5a89998ed14e0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Logo with Gimmicks\"\nauthor: \"Hubert Baechli\"\ndate: \"04-18-2025\"\n---\n\n\n\n\n\n\n# Logo\n\n## Basic Commands\n\n### CLEARSCREEN (CS)\n\nClear the screen and initializing the field\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCLEARSCREEN <- function () {\n  rm(list = ls(envir = LOGO), envir = LOGO)\n  new_field(5)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCS <- function () {\n  CLEARSCREEN()\n}\n```\n:::\n\n\n\n\n### HIDETURTLE (HT)\n\nDon't show the turtle cursor.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHIDETURTLE <- function () {\n  LOGO$turtle <- FALSE\n  record_path(turtle = LOGO$turtle)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nHT <- function () {\n  HIDETURTLE()\n}\n```\n:::\n\n\n\n\n### SHOWTURTLE (ST)\n\nShow the turtle cursor.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSHOWTURTLE <- function () {\n  LOGO$turtle <- TRUE\n  record_path(turtle = LOGO$turtle)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nST <- function () {\n  SHOWTURTLE()\n}\n```\n:::\n\n\n\n\n### FORWARD (FD)\n\nMove forward *steps*.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFORWARD <- function (step) {\n  angle <- LOGO$path$rad[LOGO$pos] \n  x0 <- LOGO$path$x[LOGO$pos]\n  y0 <- LOGO$path$y[LOGO$pos]\n  \n  max_step <- 1\n  \n  if (abs(step) > max_step) {\n    n_step <- abs(step)%/%(max_step * 1.5) + 1\n    Seq0 <- seq(from = 0, to = 1, by = 1/n_step)\n    Seq0 <- Seq0[-1]\n    steps <- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n    steps <- steps * step\n  } else {\n    steps <- step\n  }\n  \n  x1 <- x0 + cos(angle) * steps\n  y1 <- y0 + sin(angle) * steps\n  \n  record_path(x = x1, y = y1, path_color = LOGO$path_color)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nFD <- function (step) {\n  FORWARD(step)\n}\n```\n:::\n\n\n\n\n### BACK (BK)\n\nMove back *steps*.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBACK <- function (steps) {\n  FORWARD(-steps)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nBK <- function (steps) {\n  BACK(steps)\n}\n```\n:::\n\n\n\n\n### LEFT (LT)\n\nTurn left this many degrees. Negative degrees work too, they'll turn it right.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLEFT <- function (degs) {\n  LOGO$heading <- LOGO$heading + degs\n  LOGO$heading <- LOGO$heading %% 360\n  record_path(rad = LOGO$heading * pi / 180)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nLT <- function (degs) {\n  LEFT(degs)\n}\n```\n:::\n\n\n\n\n### RIGHT (RT)\n\nTurn right this many degrees.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRIGHT <- function (degs) {\n  LEFT(-degs)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nRT <- function (degs) {\n  RIGHT(degs)\n}\n```\n:::\n\n\n\n\n### SETHEADING (SH)\n\nTurn to an absolute heading of *degrees*.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETHEADING <- function (deg) {\n  LOGO$heading <- deg\n  record_path(rad = LOGO$heading * pi / 180)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSH <- function (deg) {\n  SETHEADING(deg)\n}\n```\n:::\n\n\n\n\n### SETPOS (SP)\n\nSet the position to *x, y* coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOS <- function (x1, y1) {\n  record_path(x = x1, y = y1, path_color = \"transparent\")\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSP <- function (x1, y1) {\n  SETPOS(x1, y1)\n}\n```\n:::\n\n\n\n\n### HOME\n\nMove back to the home position.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHOME <- function () {\n  SETPOS(x1 = 0, y1 = 0)\n}\n```\n:::\n\n\n\n\n### SETPOSX (SPX)\n\nSet the horizontal position to *x*.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOSX <- function (x1) {\n  SETPOS(x1, y1 = LOGO$path$y[LOGO$pos])\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPX <- function (x1) {\n  SETPOSX(x1)\n}\n```\n:::\n\n\n\n\n### SETPOSY (SPY)\n\nSet the vertical position to *y*.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPOSY <- function (y1) {\n  SETPOS(x1 = LOGO$path$x[LOGO$pos], y1)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPY <- function (y1) {\n  SETPOSY(y1)\n}\n```\n:::\n\n\n\n\n## Gimmicks\n\n### SETPATHCOLOR (SPC)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETPATHCOLOR <- function (path_color) {\n  LOGO$path_color <- path_color\n  record_path(path_color = LOGO$path_color)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPC <- function (path_color) {\n  SETPATHCOLOR(path_color)\n}\n```\n:::\n\n\n\n\n### SETTURTLECOLOR (STC)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETTURTLECOLOR <- function (turtle_color) {\n  LOGO$turtle_color <- turtle_color\n  record_path(turtle_color = LOGO$turtle_color)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSTC <- function (turtle_color) {\n  SETTURTLECOLOR(turtle_color)\n}\n```\n:::\n\n\n\n\n### SETNEWCHUNK (SNC)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETNEWCHUNK <- function () {\n  LOGO$chunk <- LOGO$chunk + 1\n  record_path(chunk = LOGO$chunk)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSNC <- function () {\n  SETNEWCHUNK()\n}\n```\n:::\n\n\n\n\n### UNDOCHUNK (UNDO)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUNDOCHUNK <- function () {\n  last_chunk <- max(LOGO$path$chunk)\n  if (last_chunk > 1) {\n    LOGO$path <- LOGO$path[LOGO$path$chunk != last_chunk,]\n  } else {\n    CLEARSCREEN() \n  }\n  \n  LOGO$chunk <- max(LOGO$path$chunk)\n  LOGO$pos <- nrow(LOGO$path)\n  LOGO$heading <- LOGO$path$rad[LOGO$pos] * 180 / pi \n  LOGO$turtle <- LOGO$path$turtle[LOGO$pos]\n  LOGO$turtle_color <- LOGO$path$turtle_color[LOGO$pos]\n  \n  last_pos <- LOGO$pos\n  while (LOGO$path$path_color[last_pos] == \"transparent\" && last_pos > 0) {\n    last_pos <- last_pos - 1\n  }\n  if (last_pos == 0) {\n    LOGO$path_color <- \"blue\"\n  } else {\n    LOGO$path_color <- LOGO$path$path_color[last_pos]\n  }\n  REPLOT()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nUNDO <- function () {\n  UNDOCHUNK()\n}\n```\n:::\n\n\n\n\n### SETSPEED (SPEED)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSETSPEED <- function (speed) {\n  speed <- pmax(speed, 1)\n  speed <- round(speed)\n  LOGO$speed <- speed\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSPEED <- function (speed) {\n  SETSPEED(speed)\n}\n```\n:::\n\n\n\n\n### REPLOT\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nREPLOT <- function (chunk = FALSE) {\n  PLOT(chunk)\n}\n```\n:::\n\n\n\n\n### SAVEPATH (SAVE)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSAVESCREEN <- function (name) {\n  name_gif <- paste0(name, \".gif\")\n  REPLOT()\n  file.copy(from = file.path(tempdir(), \"Logo_Output.gif\"), \n            to = here( name_gif), \n            overwrite = TRUE)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nSAVE <- function (name) {\n  SAVESCREEN(name)\n}\n```\n:::\n\n\n\n\n### QUITLOGO (QUIT)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nQUITLOGO <- function () {\n  if (exists(\"LOGO\", envir = .GlobalEnv)) {\n  rm(LOGO, envir = .GlobalEnv)\n}\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nQUIT <- function () {\n  QUITLOGO()\n}\n```\n:::\n\n\n\n\n## Parsing Prompts\n\n### Clean strings\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_prompt <- function (Prompt) {\n  Prompt <- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt <- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt <- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt <- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt <- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt <- trimws(Prompt)\n  Prompt\n}\n```\n:::\n\n\n\n\n### Analyzing and splitting Code\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreakup_String <- function(String) {\n  cl_String <- clean_prompt(String)\n  split_String <- strsplit(cl_String, \" \")[[1]]\n  df <- data.frame(Code = split_String)\n  \n  n_func <- 0\n  df$ID_Func <- rep(0, nrow(df))\n  \n  n_par <- 0\n  df$ID_Par <- rep(0, nrow(df))\n  \n  ID <- 1\n  df$ID_Repeat <- rep(0, nrow(df))\n  \n  brakets <- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level <- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat <- rep(1, nrow(df))\n  \n  is_par_braket <- FALSE\n  \n  i <- 1\n  imax <- nrow(df) + 1\n  \n  while ( i < imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par <- n_par + 1\n        is_par_braket <- TRUE\n        i <- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket <- FALSE\n        i <- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      } else {\n        inLower <- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] <- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] <- paste0(\"'\",inLower,\"'\")\n        } else if (exists(inLower)) {\n          df$Code[i] <- inLower\n        }  else {\n          df$Code[i] <- paste0(\"'\",df$Code[i],\"'\")\n        }\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] <- FALSE\n      level <- brakets$ID[max(which(brakets$Status == TRUE))]\n      i <- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par <- n_par + 1\n        df$ID_Func[i] <- n_func\n        df$ID_Par[i] <- n_par\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      } else {\n        inCaps <- toupper(df$Code[i])\n        \n        is_LOGO_func <- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func <- n_func + 1\n          df$Code[i] <- inCaps\n        }\n      \n        is_repeat <- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func <- n_func + 1\n          ID <- ID + 1\n          i = i + 2\n          df$Code[i] <- inCaps\n          brakets <- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level <- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] <- n_func\n        df$ID_Repeat[i] <- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] <- brakets$n[brakets$ID == level]\n        i <- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCodeLine <- \"CS repeat 2 [fd [-pi/n]] sPc [black]\"\ncl_splited <-breakup_String(CodeLine)\ncl_splited\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n4   REPEAT       2      0         2        2\n5       FD       3      0         2        2\n7        -       3      1         2        2\n8       pi       3      1         2        2\n9        /       3      1         2        2\n10     (n)       3      1         2        2\n13     SPC       4      0         1        1\n15 'black'       4      2         1        1\n```\n\n\n:::\n:::\n\n\n\n\n### Create Calls\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_Calls <- function (splited) {\n  Calls <- splited %>%\n    group_by(ID_Func, ID_Par) %>%\n    mutate(Func_Par = ifelse(ID_Par > 0,1,0),\n           Code = ifelse(first(ID_Par) > 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %>%\n    \n    group_by(ID_Func, Func_Par) %>%\n    mutate(Code = ifelse(first(Func_Par) > 0, \n                         paste0(Code, collapse = \", \"), \n                         Code)) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %>%\n  \n    group_by(ID_Func) %>%\n    mutate(Code = ifelse(n() > 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(\")),\n           Code = paste0(Code, \")\")) %>%\n    ungroup() %>%\n    distinct(Code, ID_Func, .keep_all = TRUE) %>%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %>%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call <- data.frame(Call = \"SETNEWCHUNK()\", ID = 1, n = 1)\n    last_call <- data.frame(Call = \"PLOT()\", ID = 1, n = 1)\n    Calls <- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCallshort <- create_Calls(cl_splited)\nCallshort \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Call ID n\n1 SETNEWCHUNK()  1 1\n2          CS()  1 1\n3      REPEAT()  2 2\n4   FD(-pi/(n))  2 2\n5  SPC('black')  1 1\n6        PLOT()  1 1\n```\n\n\n:::\n:::\n\n\n\n\n### Expand Repeats\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand_Repeats <- function (Calls) {\n  IDmax <- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax > 1){\n    \n    dfm <- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID <- range(which(Calls$ID == IDmax))\n    n <- Calls$n[rID[1]] \n    middle <- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub <- Calls[middle, ] %>%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm <- rbind(dfm,dfm_sub)\n      }\n    dfm$ID <- Calls$ID[rID[1]-1]\n    dfm$n <- Calls$n[rID[1]-1]\n    \n    before <- 1:(rID[1] - 1)\n    dfb <- Calls[before, ]\n    \n    after <- (rID[2] + 1):nrow(Calls)\n    dfa <- Calls[after, ]\n    \n    Calls <- rbind(dfb,dfm,dfa)\n    IDmax <- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCalls <- expand_Repeats(Callshort)\nCalls\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SETNEWCHUNK()\" \"CS()\"          \"FD(-pi/1)\"     \"FD(-pi/2)\"    \n[5] \"SPC('black')\"  \"PLOT()\"       \n```\n\n\n:::\n:::\n\n\n\n\n### Run Calls\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_prompt <- function (Prompt) {\n  Prompt_splited <- breakup_String(Prompt)\n  Callshort <- create_Calls(Prompt_splited)\n  Calls <- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    eval(parse(text = as.character(Calls[i])))\n    }\n}\n```\n:::\n\n\n\n\n## Helper Functions\n\n### New field\n\nInitializing the game\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_field <- function (size) {\n  dir_path <- here(\"LOGO\", \"temp\")\n  chunk <- 1\n  pos <- 2\n  heading <- 0\n  turtle <- TRUE\n  turtle_color <- \"red\"\n  path_color <- \"blue\"\n  speed <- 50\n  path <- data.frame(\n    chunk = rep(1, pos),\n    x = rep(0, pos),\n    y = rep(0, pos),\n    rad = rep(0, pos),\n    path_color = rep(\"transparent\", pos),\n    turtle = c(FALSE, rep(turtle, pos - 1)),\n    turtle_color = rep(turtle_color, pos),\n    stringsAsFactors = FALSE\n  )\n  \n  LOGO$field_name = \"LOGO\"\n  LOGO$field_dir = here()\n  LOGO$size = abs(size)\n  LOGO$chunk = chunk\n  LOGO$pos = pos\n  LOGO$heading = heading\n  LOGO$turtle = turtle\n  LOGO$turtle_color = turtle_color\n  LOGO$path_color = path_color\n  LOGO$speed = speed\n  LOGO$path = path\n}\n```\n:::\n\n\n\n\n### Record Path\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n record_path <- function (chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   n <- max(length(x),1)\n   template <- LOGO$path[LOGO$pos, ]\n   \n   if (n > 1) {\n     newrows <- template[rep(1,n), ]\n     new_pos <- LOGO$pos + (1:n)\n   } else {\n     newrows <- template\n     new_pos <- LOGO$pos + 1\n   }\n   \n   \n   if (!is.null(chunk)) newrows$chunk <- chunk\n   if (!is.null(x)) newrows$x <- x\n   if (!is.null(y)) newrows$y <- y\n   if (!is.null(rad)) newrows$rad <- rad\n   if (!is.null(path_color)) newrows$path_color <- path_color\n   if (!is.null(turtle)) newrows$turtle <- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color <- turtle_color\n   \n   LOGO$path[new_pos,] <- newrows\n   LOGO$pos <- nrow(LOGO$path)\n}\n```\n:::\n\n\n\n\n## Plot Functions\n\n### Field\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_field <- function (stat) {\n  maxpath <- ceiling(max(abs(LOGO$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  LOGO$size <- max(c(LOGO$size, maxpath), na.rm = TRUE)\n\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-LOGO$size, LOGO$size),\n              ylim = c(-LOGO$size, LOGO$size),\n              asp = 1)\n  box()\n}\n```\n:::\n\n\n\n\n### Path\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_path <- function (stat) {\n  if (stat > 1) {\n    path_stat <- LOGO$path[1:stat,]\n    segments(x0 = path_stat$x[-stat], \n             y0 = path_stat$y[-stat],\n             x1 = path_stat$x[-1], \n             y1 = path_stat$y[-1],\n             col = path_stat$path_color[-1], \n             lwd = 2)\n  }\n}\n```\n:::\n\n\n\n\n### Turtle\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_turtle <- function (stat) {\n  show <-  LOGO$path$turtle[stat]\n  if (show) {\n    pos_x <- LOGO$path$x[stat]\n    pos_y <- LOGO$path$y[stat]\n    symbols(x = pos_x,\n            y = pos_y,\n            circles = 0.02 * LOGO$size,\n            inches = FALSE,\n            fg = NA,\n            bg = LOGO$path$turtle_color[stat],\n            add = TRUE)\n    arrow_length <- 0.1 * LOGO$size\n    angle <- LOGO$path$rad[stat]\n    arrows(pos_x,\n           pos_y,\n           pos_x + cos(angle) * arrow_length,\n           pos_y + sin(angle) * arrow_length,\n           col = LOGO$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n}\n```\n:::\n\n\n\n\n### Stat\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_stat <- function (stat = NULL) {\n  if(is.null(stat)) stat <- nrow(LOGO$path)\n  \n  tmpfile <- tempfile(fileext = \".png\")\n  png(filename = tmpfile, width = 600, height = 600, res = 150)\n  \n  plot_field(stat)\n  plot_path(stat)\n  plot_turtle(stat)\n  \n  dev.off()\n  img <- image_read(tmpfile)\n  \n  unlink(tmpfile)\n\n  img\n\n}\n```\n:::\n\n\n\n\n### PLOT (Animation)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPLOT <- function (chunk = TRUE) {\n  invisible(NULL)\n  \n  if (chunk) {\n    Range <- range(which(LOGO$path$chunk == max(LOGO$chunk)))\n    rmin <- max(2,Range[1])\n    rmax <- Range[2]\n    } else {\n      rmin <- 2\n      rmax <- nrow(LOGO$path)\n    }\n  \n  step <- LOGO$speed/(rmax-rmin)\n  step <- pmin(pmax(step, 1/200), 1)\n  Seq0 <- seq(from = 0, to = 1, by = step)\n  plot_seq <- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq <- (rmax - rmin) * plot_seq + rmin\n  plot_seq <- round(plot_seq)\n  plot_seq <- unique(plot_seq)\n  \n  img_list <- lapply(plot_seq, function(i) plot_stat(i))\n  Logo_Output <- image_animate(image_join(img_list), \n                             fps = 10, loop = 1,\n                             optimize = TRUE) \n  \n  gif_path <- file.path(tempdir(), \"Logo_Output.gif\")\n  image_write(Logo_Output, path = gif_path)\n  \n  print(Logo_Output)\n}\n```\n:::\n\n\n\n\n## Application\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO <- function(string) {\n  if (!exists(\"LOGO\", envir = .GlobalEnv)) {\n    assign(\"LOGO\", new.env(), envir = .GlobalEnv)\n    LOGO <- get(\"LOGO\", envir = .GlobalEnv)\n    new_field(5)\n  } else {\n    LOGO <- get(\"LOGO\", envir = .GlobalEnv)\n  }\n  run_prompt(string)\n}\n```\n:::\n\n\n\n\n# Run Game\n\n## Example from the homepage\n\nwith some fancy shadow and color effects\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\")\nrun_LOGO(\"REPEAT 20 [RepeaT 180 [FD 1 RT 2] RT 18]\")\nrun_LOGO(\"SPEED 100\")\nrun_LOGO(\"Home SpC [gREEN] StC [blue]\")\nrun_LOGO(\"REPEaT 20.1 [rEPEAT 180 [fD 1 RT 2] RT 18]\")\nrun_LOGO(\"UndoChunk\")\nrun_LOGO(\"SpC [blue] StC [green]\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [green] StC [red] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [yellow] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [red] rt 18 ht\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 360 [fD 0.5 RT 1] RT 72]\")\n```\n:::\n\n\n\n\n### Saved Output\n\nyou can also save the output (Plot) for showing it around later\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo01]\")\n```\n:::\n\n\n\n\n![](Logo01.gif)\n\n## Other Exercises\n\nSince `n` is also used as a loop variable in my program, handling many other exercises doesn't pose any issues.\n\n<https://softwareprogramming4kids.com/loops-in-logo/>\n\n### Exercise 1:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS\")\nrun_LOGO(\"REPEAT 80 [FD [N*2] RT 90]\")\nrun_LOGO(\"undo\")\nrun_LOGO(\"REPEAT 80 [FD [N*2^(N/40)] RT 90]\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo02]\")\n```\n:::\n\n\n\n\n![](Logo02.gif)\n\n### Exercise 2:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS REPEAT 50 [ FD [n * 5]  RIGHT 144 ]\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo03]\")\n```\n:::\n\n\n\n\n![](Logo03.gif)\n\n### Exercise 3:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS REPEAT 150 [ FD [n * 2]  RT 91 ]\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1 saVe [Logo04]\")\n```\n:::\n\n\n\n\n![](Logo04.gif)\n\n# Quit LOGO\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"QUIT\")\n```\n:::\n\n\n\n\n## Testing Back\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_LOGO(\"CS\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 7\n  format width height colorspace matte filesize density\n  <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>  \n1 gif      600    600 sRGB       FALSE        0 59x59  \n```\n\n\n:::\n\n```{.r .cell-code}\nrun_LOGO(\"SPEED 1\")\nrun_LOGO(\"FD 200 lt 90 fd 50 lt 90\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 82 × 7\n   format width height colorspace matte filesize density\n   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>  \n 1 gif      600    600 sRGB       FALSE        0 59x59  \n 2 gif        1      1 sRGB       TRUE         0 59x59  \n 3 gif        1      1 sRGB       TRUE         0 59x59  \n 4 gif        1      1 sRGB       TRUE         0 59x59  \n 5 gif        1      1 sRGB       TRUE         0 59x59  \n 6 gif       39     13 sRGB       FALSE        0 59x59  \n 7 gif        1      1 sRGB       TRUE         0 59x59  \n 8 gif        1      1 sRGB       TRUE         0 59x59  \n 9 gif        1      1 sRGB       TRUE         0 59x59  \n10 gif        1      1 sRGB       TRUE         0 59x59  \n# ℹ 72 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nrun_LOGO(\"FD 400 \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 102 × 7\n   format width height colorspace matte filesize density\n   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>  \n 1 gif      600    600 sRGB       FALSE        0 59x59  \n 2 gif        1      1 sRGB       TRUE         0 59x59  \n 3 gif        1      1 sRGB       TRUE         0 59x59  \n 4 gif        1      1 sRGB       TRUE         0 59x59  \n 5 gif        1      1 sRGB       TRUE         0 59x59  \n 6 gif        1      1 sRGB       TRUE         0 59x59  \n 7 gif        1      1 sRGB       TRUE         0 59x59  \n 8 gif        1      1 sRGB       TRUE         0 59x59  \n 9 gif        1      1 sRGB       TRUE         0 59x59  \n10 gif        1      1 sRGB       TRUE         0 59x59  \n# ℹ 92 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nrun_LOGO(\"rt 90 fd 50 lt 90\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 7\n   format width height colorspace matte filesize density\n   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>  \n 1 gif      600    600 sRGB       FALSE        0 59x59  \n 2 gif       38     38 sRGB       FALSE        0 59x59  \n 3 gif        1      1 sRGB       TRUE         0 59x59  \n 4 gif        1      1 sRGB       TRUE         0 59x59  \n 5 gif        1      1 sRGB       TRUE         0 59x59  \n 6 gif        1      1 sRGB       TRUE         0 59x59  \n 7 gif        1      1 sRGB       TRUE         0 59x59  \n 8 gif       14     38 sRGB       FALSE        0 59x59  \n 9 gif       14     44 sRGB       FALSE        0 59x59  \n10 gif       14     52 sRGB       FALSE        0 59x59  \n11 gif       14     64 sRGB       FALSE        0 59x59  \n12 gif       14     49 sRGB       FALSE        0 59x59  \n13 gif       14     41 sRGB       FALSE        0 59x59  \n14 gif       14     38 sRGB       FALSE        0 59x59  \n15 gif        1      1 sRGB       TRUE         0 59x59  \n16 gif        1      1 sRGB       TRUE         0 59x59  \n17 gif        1      1 sRGB       TRUE         0 59x59  \n18 gif       38     38 sRGB       FALSE        0 59x59  \n```\n\n\n:::\n\n```{.r .cell-code}\nrun_LOGO(\"bk 400\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 102 × 7\n   format width height colorspace matte filesize density\n   <chr>  <int>  <int> <chr>      <lgl>    <int> <chr>  \n 1 gif      600    600 sRGB       FALSE        0 59x59  \n 2 gif        1      1 sRGB       TRUE         0 59x59  \n 3 gif        1      1 sRGB       TRUE         0 59x59  \n 4 gif        1      1 sRGB       TRUE         0 59x59  \n 5 gif        1      1 sRGB       TRUE         0 59x59  \n 6 gif        1      1 sRGB       TRUE         0 59x59  \n 7 gif        1      1 sRGB       TRUE         0 59x59  \n 8 gif        1      1 sRGB       TRUE         0 59x59  \n 9 gif        1      1 sRGB       TRUE         0 59x59  \n10 gif        1      1 sRGB       TRUE         0 59x59  \n# ℹ 92 more rows\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}